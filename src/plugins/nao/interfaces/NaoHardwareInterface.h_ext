
/***************************************************************************
 *  NaoHardwareInterface.h - Fawkes BlackBoard Interface - NaoHardwareInterface
 *
 *  Templated created:   Thu Oct 12 10:49:19 2006
 *  Copyright  2008  Tim Niemueller
 *
 ****************************************************************************/

/*  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version. A runtime exception applies to
 *  this software (see LICENSE.GPL_WRE file mentioned below for details).
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  Read the full text in the LICENSE.GPL_WRE file in the doc directory.
 */

#ifndef __INTERFACES_NAOHARDWAREINTERFACE_H_
#define __INTERFACES_NAOHARDWAREINTERFACE_H_

#include <interface/interface.h>
#include <interface/message.h>
#include <interface/field_iterator.h>

namespace fawkes {

class NaoHardwareInterface : public Interface
{
 /// @cond INTERNALS
 INTERFACE_MGMT_FRIENDS(NaoHardwareInterface)
 /// @endcond
 public:
  /* constants */
  static const uint32_t SERVO_head_yaw;
  static const uint32_t SERVO_head_pitch;
  static const uint32_t SERVO_l_shoulder_pitch;
  static const uint32_t SERVO_l_shoulder_roll;
  static const uint32_t SERVO_l_elbow_yaw;
  static const uint32_t SERVO_l_elbow_roll;
  static const uint32_t SERVO_l_hip_yaw_pitch;
  static const uint32_t SERVO_l_hip_roll;
  static const uint32_t SERVO_l_hip_pitch;
  static const uint32_t SERVO_l_knee_pitch;
  static const uint32_t SERVO_l_ankle_pitch;
  static const uint32_t SERVO_l_ankle_roll;
  static const uint32_t SERVO_r_hip_yaw_pitch;
  static const uint32_t SERVO_r_hip_roll;
  static const uint32_t SERVO_r_hip_pitch;
  static const uint32_t SERVO_r_knee_pitch;
  static const uint32_t SERVO_r_ankle_pitch;
  static const uint32_t SERVO_r_ankle_roll;
  static const uint32_t SERVO_r_shoulder_pitch;
  static const uint32_t SERVO_r_shoulder_roll;
  static const uint32_t SERVO_r_elbow_yaw;
  static const uint32_t SERVO_r_elbow_roll;
  static const uint32_t SERVO_min;
  static const uint32_t SERVO_max;
  static const float USD_left_left;
  static const float USD_left_right;
  static const float USD_right_left;
  static const float USD_right_right;

  /** 
	This determines the type of the interpolation.
       */
  typedef enum {
    INTERPOLATION_LINEAR /**< Linear interpolation. */,
    INTERPOLATION_SMOOTH /**< Smooth interpolation. */
  } InterpolationType;
  const char * tostring_InterpolationType(InterpolationType value) const;

 private:
#pragma pack(push,4)
  /** Internal data storage, do NOT modify! */
  typedef struct {
    int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
    int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
    bool servo_enabled; /**< True if servos are enabled, false otherwise */
    float head_yaw; /**< Head yaw */
    float head_pitch; /**< Head pitch */
    float l_shoulder_pitch; /**< Left shoulder pitch */
    float l_shoulder_roll; /**< Left shoulder roll */
    float l_elbow_yaw; /**< Left elbow yaw */
    float l_elbow_roll; /**< Left elbow roll */
    float l_hip_yaw_pitch; /**< Left hip yaw pitch */
    float l_hip_roll; /**< Left hip roll */
    float l_hip_pitch; /**< Left hip pitch */
    float l_knee_pitch; /**< Left knee pitch */
    float l_ankle_pitch; /**< Left ankle pitch */
    float l_ankle_roll; /**< Left ankle roll */
    float r_hip_yaw_pitch; /**< Right hip yaw pitch */
    float r_hip_roll; /**< Right hip roll */
    float r_hip_pitch; /**< Right hip pitch */
    float r_knee_pitch; /**< Right knee pitch */
    float r_ankle_pitch; /**< Right ankle pitch */
    float r_ankle_roll; /**< Right ankle roll */
    float r_shoulder_pitch; /**< Right shoulder pitch */
    float r_shoulder_roll; /**< Right shoulder roll */
    float r_elbow_yaw; /**< Right elbow yaw */
    float r_elbow_roll; /**< Right elbow roll */
    float accel_x; /**< Accelerometer x */
    float accel_y; /**< Accelerometer y */
    float accel_z; /**< Accelerometer z */
    float gyro_x; /**< Gyrometer x */
    float gyro_y; /**< Gyrometer y */
    float gyro_ref; /**< Gyrometer reference */
    float angle_x; /**< Angle x */
    float angle_y; /**< Angle y */
    float l_fsr_fl; /**< Left FSR front left */
    float l_fsr_fr; /**< Left FSR front right */
    float l_fsr_rl; /**< Left FSR rear left */
    float l_fsr_rr; /**< Left FSR rear right */
    float r_fsr_fl; /**< Right FSR front left */
    float r_fsr_fr; /**< Right FSR front right */
    float r_fsr_rl; /**< Right FSR rear left */
    float r_fsr_rr; /**< Right FSR rear right */
    float ultrasonic_distance; /**< Ultrasonic sensor reading */
    float ultrasonic_direction; /**< Direction that was used to gather the ultrasonic reading. */
    float l_bumper_l; /**< Left foot bumper left side */
    float l_bumper_r; /**< Left foot bumper right side */
    float r_bumper_l; /**< Right foot bumper left side */
    float r_bumper_r; /**< Right foot bumper right side */
    float chest_button; /**< Chest button state */
    float battery_charge; /**< Battery charge */
    int32_t time; /**< 
      Current reference time in ms. For real hardware this is the DCM time.
      Times in messages are always offsets to the current time and the current
      time is added before executing the command.
     */
  } NaoHardwareInterface_data_t;
#pragma pack(pop)

  NaoHardwareInterface_data_t *data;

 public:
  /* messages */
  class SetServosMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      float head_yaw; /**< Head yaw */
      float head_pitch; /**< Head pitch */
      float l_shoulder_pitch; /**< Left shoulder pitch */
      float l_shoulder_roll; /**< Left shoulder roll */
      float l_elbow_yaw; /**< Left elbow yaw */
      float l_elbow_roll; /**< Left elbow roll */
      float l_hip_yaw_pitch; /**< Left hip yaw pitch */
      float l_hip_roll; /**< Left hip roll */
      float l_hip_pitch; /**< Left hip pitch */
      float l_knee_pitch; /**< Left knee pitch */
      float l_ankle_pitch; /**< Left ankle pitch */
      float l_ankle_roll; /**< Left ankle roll */
      float r_hip_yaw_pitch; /**< Right hip yaw pitch */
      float r_hip_roll; /**< Right hip roll */
      float r_hip_pitch; /**< Right hip pitch */
      float r_knee_pitch; /**< Right knee pitch */
      float r_ankle_pitch; /**< Right ankle pitch */
      float r_ankle_roll; /**< Right ankle roll */
      float r_shoulder_pitch; /**< Right shoulder pitch */
      float r_shoulder_roll; /**< Right shoulder roll */
      float r_elbow_yaw; /**< Right elbow yaw */
      float r_elbow_roll; /**< Right elbow roll */
      int32_t time; /**< 
      Current reference time in ms. For real hardware this is the DCM time.
      Times in messages are always offsets to the current time and the current
      time is added before executing the command.
     */
    } SetServosMessage_data_t;
#pragma pack(pop)

    SetServosMessage_data_t *data;

   public:
    SetServosMessage(const float ini_head_yaw, const float ini_head_pitch, const float ini_l_shoulder_pitch, const float ini_l_shoulder_roll, const float ini_l_elbow_yaw, const float ini_l_elbow_roll, const float ini_l_hip_yaw_pitch, const float ini_l_hip_roll, const float ini_l_hip_pitch, const float ini_l_knee_pitch, const float ini_l_ankle_pitch, const float ini_l_ankle_roll, const float ini_r_hip_yaw_pitch, const float ini_r_hip_roll, const float ini_r_hip_pitch, const float ini_r_knee_pitch, const float ini_r_ankle_pitch, const float ini_r_ankle_roll, const float ini_r_shoulder_pitch, const float ini_r_shoulder_roll, const float ini_r_elbow_yaw, const float ini_r_elbow_roll, const int32_t ini_time);
    SetServosMessage();
    ~SetServosMessage();

    SetServosMessage(const SetServosMessage *m);
    /* Methods */
    float head_yaw() const;
    void set_head_yaw(const float new_head_yaw);
    size_t maxlenof_head_yaw() const;
    float head_pitch() const;
    void set_head_pitch(const float new_head_pitch);
    size_t maxlenof_head_pitch() const;
    float l_shoulder_pitch() const;
    void set_l_shoulder_pitch(const float new_l_shoulder_pitch);
    size_t maxlenof_l_shoulder_pitch() const;
    float l_shoulder_roll() const;
    void set_l_shoulder_roll(const float new_l_shoulder_roll);
    size_t maxlenof_l_shoulder_roll() const;
    float l_elbow_yaw() const;
    void set_l_elbow_yaw(const float new_l_elbow_yaw);
    size_t maxlenof_l_elbow_yaw() const;
    float l_elbow_roll() const;
    void set_l_elbow_roll(const float new_l_elbow_roll);
    size_t maxlenof_l_elbow_roll() const;
    float l_hip_yaw_pitch() const;
    void set_l_hip_yaw_pitch(const float new_l_hip_yaw_pitch);
    size_t maxlenof_l_hip_yaw_pitch() const;
    float l_hip_roll() const;
    void set_l_hip_roll(const float new_l_hip_roll);
    size_t maxlenof_l_hip_roll() const;
    float l_hip_pitch() const;
    void set_l_hip_pitch(const float new_l_hip_pitch);
    size_t maxlenof_l_hip_pitch() const;
    float l_knee_pitch() const;
    void set_l_knee_pitch(const float new_l_knee_pitch);
    size_t maxlenof_l_knee_pitch() const;
    float l_ankle_pitch() const;
    void set_l_ankle_pitch(const float new_l_ankle_pitch);
    size_t maxlenof_l_ankle_pitch() const;
    float l_ankle_roll() const;
    void set_l_ankle_roll(const float new_l_ankle_roll);
    size_t maxlenof_l_ankle_roll() const;
    float r_hip_yaw_pitch() const;
    void set_r_hip_yaw_pitch(const float new_r_hip_yaw_pitch);
    size_t maxlenof_r_hip_yaw_pitch() const;
    float r_hip_roll() const;
    void set_r_hip_roll(const float new_r_hip_roll);
    size_t maxlenof_r_hip_roll() const;
    float r_hip_pitch() const;
    void set_r_hip_pitch(const float new_r_hip_pitch);
    size_t maxlenof_r_hip_pitch() const;
    float r_knee_pitch() const;
    void set_r_knee_pitch(const float new_r_knee_pitch);
    size_t maxlenof_r_knee_pitch() const;
    float r_ankle_pitch() const;
    void set_r_ankle_pitch(const float new_r_ankle_pitch);
    size_t maxlenof_r_ankle_pitch() const;
    float r_ankle_roll() const;
    void set_r_ankle_roll(const float new_r_ankle_roll);
    size_t maxlenof_r_ankle_roll() const;
    float r_shoulder_pitch() const;
    void set_r_shoulder_pitch(const float new_r_shoulder_pitch);
    size_t maxlenof_r_shoulder_pitch() const;
    float r_shoulder_roll() const;
    void set_r_shoulder_roll(const float new_r_shoulder_roll);
    size_t maxlenof_r_shoulder_roll() const;
    float r_elbow_yaw() const;
    void set_r_elbow_yaw(const float new_r_elbow_yaw);
    size_t maxlenof_r_elbow_yaw() const;
    float r_elbow_roll() const;
    void set_r_elbow_roll(const float new_r_elbow_roll);
    size_t maxlenof_r_elbow_roll() const;
    int32_t time() const;
    void set_time(const int32_t new_time);
    size_t maxlenof_time() const;
    virtual Message * clone() const;
  };

  class GotoAnglesMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      float time_sec; /**< Time in seconds when to reach the desired position */
      int32_t interpolation; /**< Type of interpolation */
      float head_yaw; /**< Head yaw */
      float head_pitch; /**< Head pitch */
      float l_shoulder_pitch; /**< Left shoulder pitch */
      float l_shoulder_roll; /**< Left shoulder roll */
      float l_elbow_yaw; /**< Left elbow yaw */
      float l_elbow_roll; /**< Left elbow roll */
      float l_hip_yaw_pitch; /**< Left hip yaw pitch */
      float l_hip_roll; /**< Left hip roll */
      float l_hip_pitch; /**< Left hip pitch */
      float l_knee_pitch; /**< Left knee pitch */
      float l_ankle_pitch; /**< Left ankle pitch */
      float l_ankle_roll; /**< Left ankle roll */
      float r_hip_yaw_pitch; /**< Right hip yaw pitch */
      float r_hip_roll; /**< Right hip roll */
      float r_hip_pitch; /**< Right hip pitch */
      float r_knee_pitch; /**< Right knee pitch */
      float r_ankle_pitch; /**< Right ankle pitch */
      float r_ankle_roll; /**< Right ankle roll */
      float r_shoulder_pitch; /**< Right shoulder pitch */
      float r_shoulder_roll; /**< Right shoulder roll */
      float r_elbow_yaw; /**< Right elbow yaw */
      float r_elbow_roll; /**< Right elbow roll */
    } GotoAnglesMessage_data_t;
#pragma pack(pop)

    GotoAnglesMessage_data_t *data;

   public:
    GotoAnglesMessage(const float ini_time_sec, const InterpolationType ini_interpolation, const float ini_head_yaw, const float ini_head_pitch, const float ini_l_shoulder_pitch, const float ini_l_shoulder_roll, const float ini_l_elbow_yaw, const float ini_l_elbow_roll, const float ini_l_hip_yaw_pitch, const float ini_l_hip_roll, const float ini_l_hip_pitch, const float ini_l_knee_pitch, const float ini_l_ankle_pitch, const float ini_l_ankle_roll, const float ini_r_hip_yaw_pitch, const float ini_r_hip_roll, const float ini_r_hip_pitch, const float ini_r_knee_pitch, const float ini_r_ankle_pitch, const float ini_r_ankle_roll, const float ini_r_shoulder_pitch, const float ini_r_shoulder_roll, const float ini_r_elbow_yaw, const float ini_r_elbow_roll);
    GotoAnglesMessage();
    ~GotoAnglesMessage();

    GotoAnglesMessage(const GotoAnglesMessage *m);
    /* Methods */
    float time_sec() const;
    void set_time_sec(const float new_time_sec);
    size_t maxlenof_time_sec() const;
    InterpolationType interpolation() const;
    void set_interpolation(const InterpolationType new_interpolation);
    size_t maxlenof_interpolation() const;
    float head_yaw() const;
    void set_head_yaw(const float new_head_yaw);
    size_t maxlenof_head_yaw() const;
    float head_pitch() const;
    void set_head_pitch(const float new_head_pitch);
    size_t maxlenof_head_pitch() const;
    float l_shoulder_pitch() const;
    void set_l_shoulder_pitch(const float new_l_shoulder_pitch);
    size_t maxlenof_l_shoulder_pitch() const;
    float l_shoulder_roll() const;
    void set_l_shoulder_roll(const float new_l_shoulder_roll);
    size_t maxlenof_l_shoulder_roll() const;
    float l_elbow_yaw() const;
    void set_l_elbow_yaw(const float new_l_elbow_yaw);
    size_t maxlenof_l_elbow_yaw() const;
    float l_elbow_roll() const;
    void set_l_elbow_roll(const float new_l_elbow_roll);
    size_t maxlenof_l_elbow_roll() const;
    float l_hip_yaw_pitch() const;
    void set_l_hip_yaw_pitch(const float new_l_hip_yaw_pitch);
    size_t maxlenof_l_hip_yaw_pitch() const;
    float l_hip_roll() const;
    void set_l_hip_roll(const float new_l_hip_roll);
    size_t maxlenof_l_hip_roll() const;
    float l_hip_pitch() const;
    void set_l_hip_pitch(const float new_l_hip_pitch);
    size_t maxlenof_l_hip_pitch() const;
    float l_knee_pitch() const;
    void set_l_knee_pitch(const float new_l_knee_pitch);
    size_t maxlenof_l_knee_pitch() const;
    float l_ankle_pitch() const;
    void set_l_ankle_pitch(const float new_l_ankle_pitch);
    size_t maxlenof_l_ankle_pitch() const;
    float l_ankle_roll() const;
    void set_l_ankle_roll(const float new_l_ankle_roll);
    size_t maxlenof_l_ankle_roll() const;
    float r_hip_yaw_pitch() const;
    void set_r_hip_yaw_pitch(const float new_r_hip_yaw_pitch);
    size_t maxlenof_r_hip_yaw_pitch() const;
    float r_hip_roll() const;
    void set_r_hip_roll(const float new_r_hip_roll);
    size_t maxlenof_r_hip_roll() const;
    float r_hip_pitch() const;
    void set_r_hip_pitch(const float new_r_hip_pitch);
    size_t maxlenof_r_hip_pitch() const;
    float r_knee_pitch() const;
    void set_r_knee_pitch(const float new_r_knee_pitch);
    size_t maxlenof_r_knee_pitch() const;
    float r_ankle_pitch() const;
    void set_r_ankle_pitch(const float new_r_ankle_pitch);
    size_t maxlenof_r_ankle_pitch() const;
    float r_ankle_roll() const;
    void set_r_ankle_roll(const float new_r_ankle_roll);
    size_t maxlenof_r_ankle_roll() const;
    float r_shoulder_pitch() const;
    void set_r_shoulder_pitch(const float new_r_shoulder_pitch);
    size_t maxlenof_r_shoulder_pitch() const;
    float r_shoulder_roll() const;
    void set_r_shoulder_roll(const float new_r_shoulder_roll);
    size_t maxlenof_r_shoulder_roll() const;
    float r_elbow_yaw() const;
    void set_r_elbow_yaw(const float new_r_elbow_yaw);
    size_t maxlenof_r_elbow_yaw() const;
    float r_elbow_roll() const;
    void set_r_elbow_roll(const float new_r_elbow_roll);
    size_t maxlenof_r_elbow_roll() const;
    virtual Message * clone() const;
  };

  class GotoAngleMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      uint32_t servos; /**< A concatenated list of SERVO_* constants to
      define the servos that should execute the movement. The list shall consist of
      binary or'ed SERVO_* constants. */
      float value; /**< Servo value to set for servos. */
      float time_sec; /**< Time in seconds when to reach the desired position */
      int32_t interpolation; /**< Type of interpolation */
    } GotoAngleMessage_data_t;
#pragma pack(pop)

    GotoAngleMessage_data_t *data;

   public:
    GotoAngleMessage(const uint32_t ini_servos, const float ini_value, const float ini_time_sec, const InterpolationType ini_interpolation);
    GotoAngleMessage();
    ~GotoAngleMessage();

    GotoAngleMessage(const GotoAngleMessage *m);
    /* Methods */
    uint32_t servos() const;
    void set_servos(const uint32_t new_servos);
    size_t maxlenof_servos() const;
    float value() const;
    void set_value(const float new_value);
    size_t maxlenof_value() const;
    float time_sec() const;
    void set_time_sec(const float new_time_sec);
    size_t maxlenof_time_sec() const;
    InterpolationType interpolation() const;
    void set_interpolation(const InterpolationType new_interpolation);
    size_t maxlenof_interpolation() const;
    virtual Message * clone() const;
  };

  class GotoAngleWithSpeedMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      uint32_t servos; /**< A concatenated list of SERVO_* constants to
      define the servos that should execute the movement. The list shall consist of
      binary or'ed SERVO_* constants. */
      float value; /**< Servo value to set for servos. */
      uint16_t speed; /**< Percentage of the servo speed (1-100). */
    } GotoAngleWithSpeedMessage_data_t;
#pragma pack(pop)

    GotoAngleWithSpeedMessage_data_t *data;

   public:
    GotoAngleWithSpeedMessage(const uint32_t ini_servos, const float ini_value, const uint16_t ini_speed);
    GotoAngleWithSpeedMessage();
    ~GotoAngleWithSpeedMessage();

    GotoAngleWithSpeedMessage(const GotoAngleWithSpeedMessage *m);
    /* Methods */
    uint32_t servos() const;
    void set_servos(const uint32_t new_servos);
    size_t maxlenof_servos() const;
    float value() const;
    void set_value(const float new_value);
    size_t maxlenof_value() const;
    uint16_t speed() const;
    void set_speed(const uint16_t new_speed);
    size_t maxlenof_speed() const;
    virtual Message * clone() const;
  };

  class SetServoMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      uint32_t servos; /**< A concatenated list of SERVO_* constants to
      define the servos that should execute the movement. The list shall consist of
      binary or'ed SERVO_* constants. */
      float value; /**< Servo value to set for servos. */
      int32_t time; /**< 
      Current reference time in ms. For real hardware this is the DCM time.
      Times in messages are always offsets to the current time and the current
      time is added before executing the command.
     */
    } SetServoMessage_data_t;
#pragma pack(pop)

    SetServoMessage_data_t *data;

   public:
    SetServoMessage(const uint32_t ini_servos, const float ini_value, const int32_t ini_time);
    SetServoMessage();
    ~SetServoMessage();

    SetServoMessage(const SetServoMessage *m);
    /* Methods */
    uint32_t servos() const;
    void set_servos(const uint32_t new_servos);
    size_t maxlenof_servos() const;
    float value() const;
    void set_value(const float new_value);
    size_t maxlenof_value() const;
    int32_t time() const;
    void set_time(const int32_t new_time);
    size_t maxlenof_time() const;
    virtual Message * clone() const;
  };

  class EnableServosMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
    } EnableServosMessage_data_t;
#pragma pack(pop)

    EnableServosMessage_data_t *data;

   public:
    EnableServosMessage();
    ~EnableServosMessage();

    EnableServosMessage(const EnableServosMessage *m);
    /* Methods */
    virtual Message * clone() const;
  };

  class DisableServosMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
    } DisableServosMessage_data_t;
#pragma pack(pop)

    DisableServosMessage_data_t *data;

   public:
    DisableServosMessage();
    ~DisableServosMessage();

    DisableServosMessage(const DisableServosMessage *m);
    /* Methods */
    virtual Message * clone() const;
  };

  class SetGlobalStiffnessMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      float value; /**< Stiffness value to set for all joints.(0-1) */
      int32_t time; /**< 
      Current reference time in ms. For real hardware this is the DCM time.
      Times in messages are always offsets to the current time and the current
      time is added before executing the command.
     */
    } SetGlobalStiffnessMessage_data_t;
#pragma pack(pop)

    SetGlobalStiffnessMessage_data_t *data;

   public:
    SetGlobalStiffnessMessage(const float ini_value, const int32_t ini_time);
    SetGlobalStiffnessMessage();
    ~SetGlobalStiffnessMessage();

    SetGlobalStiffnessMessage(const SetGlobalStiffnessMessage *m);
    /* Methods */
    float value() const;
    void set_value(const float new_value);
    size_t maxlenof_value() const;
    int32_t time() const;
    void set_time(const int32_t new_time);
    size_t maxlenof_time() const;
    virtual Message * clone() const;
  };

  class EmitUltrasonicWaveMessage : public Message
  {
   private:
#pragma pack(push,4)
    /** Internal data storage, do NOT modify! */
    typedef struct {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      float ultrasonic_direction; /**< Direction that was used to gather the ultrasonic reading. */
      int32_t time; /**< 
      Current reference time in ms. For real hardware this is the DCM time.
      Times in messages are always offsets to the current time and the current
      time is added before executing the command.
     */
    } EmitUltrasonicWaveMessage_data_t;
#pragma pack(pop)

    EmitUltrasonicWaveMessage_data_t *data;

   public:
    EmitUltrasonicWaveMessage(const float ini_ultrasonic_direction, const int32_t ini_time);
    EmitUltrasonicWaveMessage();
    ~EmitUltrasonicWaveMessage();

    EmitUltrasonicWaveMessage(const EmitUltrasonicWaveMessage *m);
    /* Methods */
    float ultrasonic_direction() const;
    void set_ultrasonic_direction(const float new_ultrasonic_direction);
    size_t maxlenof_ultrasonic_direction() const;
    int32_t time() const;
    void set_time(const int32_t new_time);
    size_t maxlenof_time() const;
    virtual Message * clone() const;
  };

  virtual bool message_valid(const Message *message) const;
 private:
  NaoHardwareInterface();
  ~NaoHardwareInterface();

 public:
  /* Methods */
  bool is_servo_enabled() const;
  void set_servo_enabled(const bool new_servo_enabled);
  size_t maxlenof_servo_enabled() const;
  float head_yaw() const;
  void set_head_yaw(const float new_head_yaw);
  size_t maxlenof_head_yaw() const;
  float head_pitch() const;
  void set_head_pitch(const float new_head_pitch);
  size_t maxlenof_head_pitch() const;
  float l_shoulder_pitch() const;
  void set_l_shoulder_pitch(const float new_l_shoulder_pitch);
  size_t maxlenof_l_shoulder_pitch() const;
  float l_shoulder_roll() const;
  void set_l_shoulder_roll(const float new_l_shoulder_roll);
  size_t maxlenof_l_shoulder_roll() const;
  float l_elbow_yaw() const;
  void set_l_elbow_yaw(const float new_l_elbow_yaw);
  size_t maxlenof_l_elbow_yaw() const;
  float l_elbow_roll() const;
  void set_l_elbow_roll(const float new_l_elbow_roll);
  size_t maxlenof_l_elbow_roll() const;
  float l_hip_yaw_pitch() const;
  void set_l_hip_yaw_pitch(const float new_l_hip_yaw_pitch);
  size_t maxlenof_l_hip_yaw_pitch() const;
  float l_hip_roll() const;
  void set_l_hip_roll(const float new_l_hip_roll);
  size_t maxlenof_l_hip_roll() const;
  float l_hip_pitch() const;
  void set_l_hip_pitch(const float new_l_hip_pitch);
  size_t maxlenof_l_hip_pitch() const;
  float l_knee_pitch() const;
  void set_l_knee_pitch(const float new_l_knee_pitch);
  size_t maxlenof_l_knee_pitch() const;
  float l_ankle_pitch() const;
  void set_l_ankle_pitch(const float new_l_ankle_pitch);
  size_t maxlenof_l_ankle_pitch() const;
  float l_ankle_roll() const;
  void set_l_ankle_roll(const float new_l_ankle_roll);
  size_t maxlenof_l_ankle_roll() const;
  float r_hip_yaw_pitch() const;
  void set_r_hip_yaw_pitch(const float new_r_hip_yaw_pitch);
  size_t maxlenof_r_hip_yaw_pitch() const;
  float r_hip_roll() const;
  void set_r_hip_roll(const float new_r_hip_roll);
  size_t maxlenof_r_hip_roll() const;
  float r_hip_pitch() const;
  void set_r_hip_pitch(const float new_r_hip_pitch);
  size_t maxlenof_r_hip_pitch() const;
  float r_knee_pitch() const;
  void set_r_knee_pitch(const float new_r_knee_pitch);
  size_t maxlenof_r_knee_pitch() const;
  float r_ankle_pitch() const;
  void set_r_ankle_pitch(const float new_r_ankle_pitch);
  size_t maxlenof_r_ankle_pitch() const;
  float r_ankle_roll() const;
  void set_r_ankle_roll(const float new_r_ankle_roll);
  size_t maxlenof_r_ankle_roll() const;
  float r_shoulder_pitch() const;
  void set_r_shoulder_pitch(const float new_r_shoulder_pitch);
  size_t maxlenof_r_shoulder_pitch() const;
  float r_shoulder_roll() const;
  void set_r_shoulder_roll(const float new_r_shoulder_roll);
  size_t maxlenof_r_shoulder_roll() const;
  float r_elbow_yaw() const;
  void set_r_elbow_yaw(const float new_r_elbow_yaw);
  size_t maxlenof_r_elbow_yaw() const;
  float r_elbow_roll() const;
  void set_r_elbow_roll(const float new_r_elbow_roll);
  size_t maxlenof_r_elbow_roll() const;
  float accel_x() const;
  void set_accel_x(const float new_accel_x);
  size_t maxlenof_accel_x() const;
  float accel_y() const;
  void set_accel_y(const float new_accel_y);
  size_t maxlenof_accel_y() const;
  float accel_z() const;
  void set_accel_z(const float new_accel_z);
  size_t maxlenof_accel_z() const;
  float gyro_x() const;
  void set_gyro_x(const float new_gyro_x);
  size_t maxlenof_gyro_x() const;
  float gyro_y() const;
  void set_gyro_y(const float new_gyro_y);
  size_t maxlenof_gyro_y() const;
  float gyro_ref() const;
  void set_gyro_ref(const float new_gyro_ref);
  size_t maxlenof_gyro_ref() const;
  float angle_x() const;
  void set_angle_x(const float new_angle_x);
  size_t maxlenof_angle_x() const;
  float angle_y() const;
  void set_angle_y(const float new_angle_y);
  size_t maxlenof_angle_y() const;
  float l_fsr_fl() const;
  void set_l_fsr_fl(const float new_l_fsr_fl);
  size_t maxlenof_l_fsr_fl() const;
  float l_fsr_fr() const;
  void set_l_fsr_fr(const float new_l_fsr_fr);
  size_t maxlenof_l_fsr_fr() const;
  float l_fsr_rl() const;
  void set_l_fsr_rl(const float new_l_fsr_rl);
  size_t maxlenof_l_fsr_rl() const;
  float l_fsr_rr() const;
  void set_l_fsr_rr(const float new_l_fsr_rr);
  size_t maxlenof_l_fsr_rr() const;
  float r_fsr_fl() const;
  void set_r_fsr_fl(const float new_r_fsr_fl);
  size_t maxlenof_r_fsr_fl() const;
  float r_fsr_fr() const;
  void set_r_fsr_fr(const float new_r_fsr_fr);
  size_t maxlenof_r_fsr_fr() const;
  float r_fsr_rl() const;
  void set_r_fsr_rl(const float new_r_fsr_rl);
  size_t maxlenof_r_fsr_rl() const;
  float r_fsr_rr() const;
  void set_r_fsr_rr(const float new_r_fsr_rr);
  size_t maxlenof_r_fsr_rr() const;
  float ultrasonic_distance() const;
  void set_ultrasonic_distance(const float new_ultrasonic_distance);
  size_t maxlenof_ultrasonic_distance() const;
  float ultrasonic_direction() const;
  void set_ultrasonic_direction(const float new_ultrasonic_direction);
  size_t maxlenof_ultrasonic_direction() const;
  float l_bumper_l() const;
  void set_l_bumper_l(const float new_l_bumper_l);
  size_t maxlenof_l_bumper_l() const;
  float l_bumper_r() const;
  void set_l_bumper_r(const float new_l_bumper_r);
  size_t maxlenof_l_bumper_r() const;
  float r_bumper_l() const;
  void set_r_bumper_l(const float new_r_bumper_l);
  size_t maxlenof_r_bumper_l() const;
  float r_bumper_r() const;
  void set_r_bumper_r(const float new_r_bumper_r);
  size_t maxlenof_r_bumper_r() const;
  float chest_button() const;
  void set_chest_button(const float new_chest_button);
  size_t maxlenof_chest_button() const;
  float battery_charge() const;
  void set_battery_charge(const float new_battery_charge);
  size_t maxlenof_battery_charge() const;
  int32_t time() const;
  void set_time(const int32_t new_time);
  size_t maxlenof_time() const;
  float servo_value(uint32_t key) const;
  void set_servo_value(const uint32_t key, const float new_value);
  virtual Message * create_message(const char *type) const;

  virtual void copy_values(const Interface *other);
  virtual const char * enum_tostring(const char *enumtype, int val) const;

};

} // end namespace fawkes

#endif
